# Code generated by bitproto. DO NOT EDIT.


import json
from dataclasses import dataclass, field
from typing import ClassVar, Dict, List

from bitprotolib import bp


# The different types of nodes currently possible, will be exanded in the future.
NodeType = int # 4bit
PRESSURE_TRANSDUCER_NODE: NodeType = 0
LOAD_CELL_NODE: NodeType = 1
THERMAL_COUPLE_NODE: NodeType = 2
SOLENOID_NODE: NodeType = 3

_NODETYPE_VALUE_TO_NAME_MAP: Dict[NodeType, str] = {
    0: "PRESSURE_TRANSDUCER_NODE",
    1: "LOAD_CELL_NODE",
    2: "THERMAL_COUPLE_NODE",
    3: "SOLENOID_NODE",
}

def bp_processor_NodeType() -> bp.Processor:
    return bp.EnumProcessor(bp.Uint(4))


@dataclass
class StagePacket(bp.MessageBase):
    """
    Must be repeated every 20ms, otherwise the solenoids will be closed. (Sent by the mainland.)
    ID: 0x01
    """
    # Number of bytes to serialize class StagePacket
    BYTES_LENGTH: ClassVar[int] = 8

    solenoid_state: List[bool] = field(default_factory=lambda: [False for _ in range(64)]) # 64bit

    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp.Array(False, 64, bp.Bool())),
        ]
        return bp.MessageProcessor(False, 64, field_processors)

    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.solenoid_state[di.i(0)] = bool(b)
        return

    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (int(self.solenoid_state[di.i(0)]) >> rshift) & 255
        return bp.byte(0)  # Won't reached

    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        return bp.NilAccessor() # Won't reached

    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s

    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)


@dataclass
class PowerPacket(bp.MessageBase):
    """
    Must be repeated every 20ms, otherwise the power will be cut to all solenoids. (Sent by the mainland.)
    ID: 0x00
    """
    # Number of bytes to serialize class PowerPacket
    BYTES_LENGTH: ClassVar[int] = 1

    system_powered: bool = False # 1bit
    siren: bool = False # 1bit

    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp.Bool()),
            bp.MessageFieldProcessor(2, bp.Bool()),
        ]
        return bp.MessageProcessor(False, 2, field_processors)

    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.system_powered = bool(b)
        if di.field_number == 2:
            self.siren = bool(b)
        return

    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (int(self.system_powered) >> rshift) & 255
        if di.field_number == 2:
            return (int(self.siren) >> rshift) & 255
        return bp.byte(0)  # Won't reached

    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        return bp.NilAccessor() # Won't reached

    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s

    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)


@dataclass
class BlinkPacket(bp.MessageBase):
    """
    Causes a Island node to blink it's USER LED for 5 seconds.
    ID: 0x06
    """
    # Number of bytes to serialize class BlinkPacket
    BYTES_LENGTH: ClassVar[int] = 1

    node_id: int = 0 # 8bit

    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp.Uint(8)),
        ]
        return bp.MessageProcessor(False, 8, field_processors)

    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.node_id |= (int(b) << lshift)
        return

    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (self.node_id >> rshift) & 255
        return bp.byte(0)  # Won't reached

    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        return bp.NilAccessor() # Won't reached

    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s

    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)


@dataclass
class SensorDataPacket(bp.MessageBase):
    """
    ID: 0x03
    """
    # Number of bytes to serialize class SensorDataPacket
    BYTES_LENGTH: ClassVar[int] = 6

    node_id: int = 0 # 8bit
    sensor_id: int = 0 # 4bit
    sensor_data: int = 0 # 32bit

    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp.Uint(8)),
            bp.MessageFieldProcessor(2, bp.Uint(4)),
            bp.MessageFieldProcessor(4, bp.Uint(32)),
        ]
        return bp.MessageProcessor(False, 44, field_processors)

    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.node_id |= (int(b) << lshift)
        if di.field_number == 2:
            self.sensor_id |= (int(b) << lshift)
        if di.field_number == 4:
            self.sensor_data |= (int(b) << lshift)
        return

    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (self.node_id >> rshift) & 255
        if di.field_number == 2:
            return (self.sensor_id >> rshift) & 255
        if di.field_number == 4:
            return (self.sensor_data >> rshift) & 255
        return bp.byte(0)  # Won't reached

    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        return bp.NilAccessor() # Won't reached

    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s

    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)


@dataclass
class PongPacket(bp.MessageBase):
    """
    Returned by all Island nodes, identifying their ID and their sensor type.
    ID: 0x05
    """
    # Number of bytes to serialize class PongPacket
    BYTES_LENGTH: ClassVar[int] = 2

    node_id: int = 0 # 8bit
    node_type: NodeType = 0 # 4bit

    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp.Uint(8)),
            bp.MessageFieldProcessor(2, bp_processor_NodeType()),
        ]
        return bp.MessageProcessor(False, 12, field_processors)

    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.node_id |= (int(b) << lshift)
        if di.field_number == 2:
            self.node_type |= (NodeType(b) << lshift)
        return

    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (self.node_id >> rshift) & 255
        if di.field_number == 2:
            return (self.node_type >> rshift) & 255
        return bp.byte(0)  # Won't reached

    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        return bp.NilAccessor() # Won't reached

    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s

    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)